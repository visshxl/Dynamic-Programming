https://www.geeksforgeeks.org/problems/partitions-with-given-difference/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=partitions-with-given-difference
class Solution {
  public:
  
// intuition:-
// s1 - s2 = d; (totalSum - s2 = s1)
// totalSum - s2 - s2 = d;
// s2 = (totalSum - d)/2;
// so we will find the total no subsets s2 with these conditions

    int mod=1e9+7;
    int totalSubsets(int ind, vector<int>& arr, int sum, vector<vector<int>>& dp){
	    if(ind==0){
	       // in case of zero the possible outcome can be 2 - take 0 or not take
	        if(sum==0 && arr[0]==0) return 2; 
	        else if(sum==0 && arr[0]!=0) return 1;
	        else if(arr[0]==sum) return 1;
	        return 0;
	    }
	    
	    if(dp[ind][sum]!=-1) return dp[ind][sum];
	    int take=0;
	    if(arr[ind]<=sum) take=totalSubsets(ind-1, arr, sum-arr[ind], dp);
	    int notTake=totalSubsets(ind-1, arr, sum, dp);
	   // modding as per the question's requirement
	    return dp[ind][sum]=(take%mod+notTake%mod)%mod;
	}
        // return totalSubsets(n-1, arr, target, dp);
    
    // tabulation same as the perfect sum problem in gfg
    
    // tabulation with space optimisation
    int countPartitions(int n, int d, vector<int>& arr) {
        int totSum=accumulate(arr.begin(), arr.end(), 0);
        if(totSum-d<0 || (totSum-d)%2) return 0;
        int target=(totSum-d)/2;
        vector<int> prev(target+1, 0);
        vector<int> curr(target+1, 0);
        if(arr[0]==0) prev[0]=2; // zero edge case 
	    else prev[0]=1;
	    
	    if(arr[0]!=0 && arr[0]<=target) prev[arr[0]]=1;
	    for(int ind=1; ind<n; ind++){
	        for(int sum=0; sum<=target; sum++){
	            int take=0;
        	    if(arr[ind]<=sum) take=prev[sum-arr[ind]];
        	    int notTake=prev[sum];
                curr[sum]=(take+notTake)%mod;
	        }
	        prev=curr;
	    }
	    return prev[target];
    }
};
